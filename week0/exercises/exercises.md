演習問題

演習1
1. 
減算
有限体では「aにbの加法逆元を加える」操作として定義される。
例えば、a−b modp を計算する場合、bの加法逆元(−b)を見つけ、a+(−b) modp を計算する。

割り算
有限体では「aにbの乗法逆元を掛ける」操作として定義される。
例えば、a divb modp を計算する場合、b の乗法逆元 b^(-1)を見つけ、a timesb^(−1) modpを計算する。

2. 拡張ユークリッド法は、2つの整数 a, b の最大公約数を求めるユークリッドの互除法を拡張したアルゴリズムで、ax + by = GCD(a, b)を満たす整数のペア x, y を同時に見つけ出すもの。

```python
def extended_euclid(a, b):
    if b == 0:
        return (1, 0)
    else:
        xd, yd = extended_euclid(b, a % b)
        return (yd, xd - a // b * yd)

```
3. 1
4. 5を法として、3÷2≡3×3≡4(mod5)
5. 7×5=35より、35≡9(mod13)であるので、9^(-1)(mod13)を求める。
9×a≡1(mod13)を満たすaを考えると、a=3より、9の乗法逆元は3である。
よって、9^(-1)≡3(mod13)


演習2
1. 2つのビット列の長さが異なるため、短い方（右側）の先頭に0を追加して長さを揃える。
ビットごとのXOR演算を行うと、
 10110101
-00110110
----------
 10000011

2. 元（要素）は、固定長 8ビットの列として表現できるが、拡大体であっても元の加算・減算は各ビットのXOR演算で処理されるので、
 10110101
-00110110
----------
 10000011

3. f(x)=x^3+x^2+1を考えると、

x=0を代入すると、
f(0)=0^3+0^2+1=1

x=1を代入すると、
f(1)=1^3+1^2+1=1+1+1=3≡1(mod2)

よって、f(x)=x^3+x^2+1


演習3
1. 
- 整数の素因数分解問題
2つの非常に大きな素数 p と q を掛け合わせて、合成数 N=p×q を作るのは非常に簡単であるが、その合成数 N だけを与えられて、元の p と q を見つけ出すのは極めて困難である、という問題。

なぜ安全か
合成数 N が大きくなると、その素因数を効率的に見つけるアルゴリズムが現在存在しないから。既知の最速アルゴリズムでも、スーパーコンピュータを使っても現実的な時間内には解けない。この困難さが、広く使われているRSA暗号の安全性の根拠となっている。

- 格子問題

なぜ安全か
格子問題の代表である最短ベクトル問題(SVP)や最近ベクトル問題(CVP)は、高次元においてNP困難 (NP-hard) であることが知られている。

NP困難とは、計算機科学における計算量のクラスの一つで、「効率的な（多項式時間での）解法が現在見つかっていない、非常に難しい問題」の集まりを指す。もしNP困難な問題を効率的に解くアルゴリズムが見つかれば、他の多くの未解決問題を解くことに繋がるため、一般的には解くのが非常に困難であると考えられている。この計算量理論における困難さが、安全性の直接的な根拠の一つ。

また、格子問題にはショアのアルゴリズムが利用できるような周期的な代数構造が見当たっていないこともあげられる

2. 指数計算法
アルゴリズムの概要
まず、小さな素数の集合（ファクターベース）を決める。次に、生成元 g を色々なべき乗（g^k）にし、その結果 mod p がファクターベースの素数だけで因数分解できるものを多数探す。これにより、ファクターベースの素数の離散対数に関する連立方程式を作る。集めた連立方程式を解き、ファクターベースの各素数の離散対数を求める。求めたい値 h について、h⋅g^sがファクターベースで因数分解できるような s を見つけ、既知の対数値を使って h の離散対数を計算する。

なぜ効率的か
このアルゴリズムの計算量は準指数時間であり、総当たり攻撃の指数時間よりも大幅に高速。問題を直接解くのではなく、一旦「小さな素数の対数」という中間問題に分解し、効率的な線形代数の手法で解決することで、全体の計算コストを劇的に下げている。

3.
5^1≡5(mod23)
5^2=25≡2(mod23)
5^3=5^2⋅5≡2⋅5=10(mod23)
5^4=5^3⋅5≡10⋅5=50≡4(mod23)  (∵ 50=2×23+4)
5^5=5^4⋅5≡4⋅5=20(mod23)
5^6=5^5⋅5≡20⋅5=100≡8(mod23) (∵ 100=4×23+8)

よって6

演習4
1. ポラードのロー法 
楕円曲線上の点で「ランダムウォーク」を行い、擬似乱数列の衝突（同じ点が再び現れること）を見つけ出すアルゴリズム。衝突を発見することで、元の離散対数を計算できます。計算量は、群の位数を n とすると、総当たり攻撃の O(n) に対して O(√n) となり、大幅に効率化されている。

2. バイナリ法
整数 n を2進数表現にして計算する方法です。n の2進数表現を左（上位ビット）から右（下位ビット）に見ていき、ビットが0なら現在計算中の点を2倍（Add）し、ビットが1なら2倍した後に元の点Pを加算（Double-and-add）する。これにより、n 回の加算が必要だった単純な方法に比べ、約 log2_(n) 回の加算・2倍算で済むため、高速。

3. bn128

4. 
